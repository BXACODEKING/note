### 一、核心数据结构
```
typedef struct {
    int conn_flag;                           // 连接状态标志
    int alarm_flag;                          // 告警标志
    report_ctrl_st report;                   // 上报控制参数
    int getInfo_flag;                        // 获取信息标志
    int response;                            // 写响应
    pthread_mutex_t datalock;                // 线程互斥锁
    
    // ⭐ 六个核心链表
    struct list_head report_data_record;     // 链表1: 变化上报记录链表
    struct list_head report_data_rt;         // 链表2: 实时数据缓存链表
    struct list_head report_data;            // 链表3: 待上报原始数据链表
    struct list_head report_list;            // 链表4: 打包好的周期上报消息链表
    struct list_head report_rt_list;         // 链表5: 打包好的实时上报消息链表
    struct list_head alarm_list;             // 链表6: 告警消息链表
} report_message_st;
```
### 二、链表节点结构
```
typedef struct {
    unsigned char *payload;      // 指向实际数据的指针
    struct list_head list;       // 内核链表节点（双向链表）
} report_node_st;
```
内存布局示意：
```
┌─────────────────┐
│ report_node_st  │
├─────────────────┤
│ payload  ───────┼──→ 指向 data_format_st 或 JSON 字符串
├─────────────────┤
│ list.prev ◄─────┼──→ 指向上一个节点
│ list.next ◄─────┼──→ 指向下一个节点
└─────────────────┘
```
### 三、六大链表的详细应用场景

#### 🔴 链表1：report_data_record - 变化上报记录链表

使用场景： policy_change 策略（变化上报模式）

作用： 记录每个设备每个变量的最后一次上报值，用于对比新数据是否发生变化。

代码位置： mqtt_reportdata.c:200-238 (publish_type_change())

工作流程：
```
// 步骤1: 新数据到来
data_format_st *data_pointer;  // 例如: device="Sensor01", var="温度", val="25.5"

// 步骤2: 遍历 report_data_record 查找历史记录
list_for_each_entry_safe(report_node, n, &report_msg->report_data_record, list) {
    ptr = (data_format_st *)report_node->payload;
    
    // 情况A: 设备名+变量名+值都相同 → 数据未变化
    if (设备名相同 && 变量名相同 && 值相同) {
        reflash = 1;  // 标记：不需要上报
        break;
    }
    
    // 情况B: 设备名+变量名相同，但值不同 → 数据变化了
    if (设备名相同 && 变量名相同) {
        update_to_report_record_list(ptr, data_pointer);  // 更新记录
        reflash = 2;  // 标记：需要上报
        break;
    }
}

// 步骤3: 处理结果
if (reflash == 0) {
    // 首次出现的变量，添加到记录链表
    add_to_list(&report_msg->report_data_record, data_pointer, sizeof(...));
}
if (reflash != 1) {
    // 值发生变化或首次出现，加入待上报队列
    add_to_list(&report_msg->report_data, data_pointer, sizeof(...));
}
```
实际例子：
```
时刻 T1: 温度=25.5 → 加入 report_data_record 并上报
时刻 T2: 温度=25.5 → 发现值未变化，不上报
时刻 T3: 温度=26.0 → 发现值变化，更新 report_data_record 并上报
```
#### 🟢 链表2：report_data_rt - 实时数据缓存链表

使用场景： policy_interval 策略的实时数据暂存

作用： 缓存最新的设备数据值（每个变量只保留最新值），用于实时查询或快速上报。

代码位置： mqtt_reportdata.c:271-300 (publish_type_rt())

工作流程：
```
// 数据去重逻辑（保留最新值）
list_for_each_entry_safe(report_node, n, &report_msg->report_data_rt, list) {
    ptr = (data_format_st *)report_node->payload;
    
    // 如果找到相同的设备和变量，更新值
    if (设备名相同 && 变量名相同) {
        update_to_report_record_list(ptr, data_pointer);  // 覆盖旧值
        reflash = false;  // 标记：已更新，不需要新增
        break;
    }
}

if (reflash) {
    // 首次出现，新增节点
    add_to_list(&report_msg->report_data_rt, data_pointer, sizeof(...));
}
```
与 report_data 的区别：

- report_data：累积所有数据，用于批量上报

- report_data_rt：只保留最新值，用于实时上报

实际例子：
```
时刻 T1: 温度=25.5 → report_data_rt 中添加节点 {"温度": "25.5"}
时刻 T2: 温度=26.0 → report_data_rt 中更新节点 {"温度": "26.0"} (覆盖)
时刻 T3: 湿度=60.0 → report_data_rt 中添加节点 {"湿度": "60.0"}
```
#### 🔵 链表3：report_data - 待上报原始数据链表

使用场景： 所有上报策略的原始数据缓存

作用： 存储所有需要上报的原始数据（data_format_st 结构），等待打包成 JSON。

数据来源：

1. publish_type_original() - 原始值上报模式（行196）

2. publish_type_change() - 变化上报模式（行234）

3. publish_type_interval() - 周期上报模式（行265）

代码位置： mqtt_reportdata.c:240-268 (publish_type_interval())

工作流程：
```
// 场景: 周期上报模式
publish_type_interval(report_msg, data_pointer) {
    // 检查是否已存在相同的设备+变量
    list_for_each_entry_safe(report_node, n, &report_msg->report_data, list) {
        if (设备名相同 && 变量名相同) {
            update_to_report_record_list(ptr, data_pointer);  // 更新值
            reflash = false;
            break;
        }
    }
    
    if (reflash) {
        add_to_list(&report_msg->report_data, data_pointer, sizeof(...));
    }
}
```
数据流转：
```
数据库回调 data_cb()
    ↓
publish_message_prepare()
    ↓
根据 policy 选择策略
    ↓
publish_type_xxx()
    ↓
add_to_list(&report_data, ...)  ← 数据存入这个链表
    ↓
report_data_subcontract_process()  ← 定时打包
    ↓
从 report_data 取出数据 → 打包成 JSON → 加入 report_list
```
#### 🟡 链表4：report_list - 打包好的周期上报消息链表

使用场景： 存储已打包成 JSON 格式的周期上报消息

作用： 经过 report_data_subcontract_process() 处理后，原始数据被打包成 JSON 字符串，存入此链表等待发送。

代码位置： mqtt_reportdata.c:440-484 (report_data_subcontract_process())

打包流程：
```
report_data_subcontract_process(report_msg) {
    // 1. 从 report_data 链表取出数据（最多 payload_size 条）
    cnt = 0;
    list_for_each_entry_safe(report_node, n, &report_msg->report_data, list) {
        memcpy(data_read + cnt*MAX_STORE_BUF_LEN, report_node->payload, sizeof(...));
        cnt++;
        
        if (cnt >= report_msg->report.payload_size) {  // 达到批量阈值
            // 2. 打包成 JSON
            report_message_create(report_msg, policy_interval, data_read, cnt);
            cnt = 0;
        }
        
        // 3. 删除已处理的节点
        list_del(&report_node->list);
        systemMemoryFree(report_node);
    }
    
    // 4. 处理剩余数据
    report_message_create(report_msg, policy_interval, data_read, cnt);
}
```
report_message_create() 内部逻辑（行340-438）：
```
// 构造 JSON 格式：
{
  "devs": [
    {
      "device": "Sensor01",
      "timestamp": 1234567890,
      "data": [
        {"key": "温度", "val": "25.5", "timestamp": 1234567890},
        {"key": "湿度", "val": "60.0", "timestamp": 1234567890}
      ]
    }
  ]
}

// 序列化为字符串
string = json_serialize_to_string_pretty(root);

// 加入 report_list 链表（行428）
add_to_list(&report_msg->report_list, buffer, strlen(buffer)+1);
```
发送流程（行593-620）：
```
report_interval_message(report_msg, mosq, mqttserver) {
    pthread_mutex_lock(&report_msg->datalock);
    
    // 1. 先将原始数据打包
    report_data_subcontract_process(report_msg);
    
    // 2. 遍历 report_list 发送
    list_for_each_entry_safe(report_node, n, &report_msg->report_list, list) {
        payload = (unsigned char *)report_node->payload;
        
        // 3. 调用 MQTT 发送
        mqtt_publish_interval_message(report_msg, mosq, mqttserver, payload);
        
        // 4. 发送成功后删除节点
        if (发送成功) {
            systemMemoryFree(report_node->payload);
            list_del(&report_node->list);
            systemMemoryFree(report_node);
        }
    }
    
    pthread_mutex_unlock(&report_msg->datalock);
}
```
#### 🟣 链表5：report_rt_list - 打包好的实时上报消息链表

使用场景： 存储实时上报的 JSON 消息（类似 report_list，但用于实时数据）

作用： report_data_rt 打包成 JSON 后存入此链表。

代码位置： mqtt_reportdata.c:486-525 (report_rt_subcontract_process())

工作流程：
```
report_rt_subcontract_process(report_msg) {
    // 从 report_data_rt 取数据 → 打包 → 加入 report_rt_list
    list_for_each_entry_safe(report_node, n, &report_msg->report_data_rt, list) {
        memcpy(data_read + cnt*MAX_STORE_BUF_LEN, report_node->payload, sizeof(...));
        cnt++;
        
        if (cnt >= report_msg->report.payload_size) {
            report_message_create(report_msg, policy_realtime, data_read, cnt);
            // ↑ mode=policy_realtime 会加入 report_rt_list (行430-432)
            cnt = 0;
        }
    }
}
```
发送流程： report_rt_message() 函数（类似 report_interval_message()）
#### 🔴 链表6：alarm_list - 告警消息链表

使用场景： 存储需要立即上报的告警数据

作用： 告警数据优先级最高，不经过批量打包，直接单独发送。

代码位置： mqtt_reportdata.c:176-185 (publish_type_alarm())

添加流程：
```
publish_type_alarm(report_msg, data_pointer) {
    // 直接加入告警链表
    add_to_list(&report_msg->alarm_list, data_pointer, sizeof(data_format_st));
    
    // 设置告警标志
    report_msg->alarm_flag = 1;
}
```
发送流程（行562-591）：
```
report_alarm_message(report_msg, mosq, mqttserver) {
    pthread_mutex_lock(&report_msg->datalock);
    
    // 遍历告警链表
    list_for_each_entry_safe(report_node, n, &report_msg->alarm_list, list) {
        data_pointer = (data_format_st *)report_node->payload;
        
        // 单独发送每条告警（不批量）
        mqtt_publish_alarm_message(report_msg, mosq, mqttserver, data_pointer);
        
        if (发送成功) {
            // 删除节点
            systemMemoryFree(report_node->payload);
            list_del(&report_node->list);
            systemMemoryFree(report_node);
        } else {
            // 发送失败，保留在链表中，下次重试
            return E_FAIL;
        }
    }
    
    pthread_mutex_unlock(&report_msg->datalock);
}
```
### 四、完整数据流转图
```
┌─────────────────────────────────────────────────────────────────┐
│  数据源：数据库回调 data_cb()                                     │
│  接收 data_format_st 数据                                        │
└─────────────────────────────────────────────────────────────────┘
                    │
                    ↓
        判断数据类型 (report_type)
                    │
        ┌───────────┼───────────┐
        │                       │
     告警数据                 普通数据
        │                       │
        ↓                       ↓
┌──────────────┐     publish_message_prepare()
│ alarm_list   │              │
│ (链表6)      │              ↓
└──────────────┘     根据 policy 选择策略
        │                     │
        │         ┌───────────┼───────────┬──────────────┐
        │         │           │           │              │
        │   policy_original  policy_change  policy_interval
        │         │           │           │
        │         ↓           ↓           ↓
        │   ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
        │   │report_  │  │report_  │  │report_  │  │report_  │
        │   │data     │  │data_    │  │data     │  │data_rt  │
        │   │(链表3)  │  │record   │  │(链表3)  │  │(链表2)  │
        │   └─────────┘  │(链表1)  │  └─────────┘  └─────────┘
        │                └─────────┘       │             │
        │                     │             │             │
        │                     └─────────────┘             │
        │                           │                     │
        │                           ↓                     ↓
        │              report_data_subcontract_process()  report_rt_subcontract_process()
        │                           │                     │
        │                           ↓                     ↓
        │                   打包成 JSON                打包成 JSON
        │                           │                     │
        │                           ↓                     ↓
        │                    ┌─────────┐           ┌─────────┐
        │                    │report_  │           │report_  │
        │                    │list     │           │rt_list  │
        │                    │(链表4)  │           │(链表5)  │
        │                    └─────────┘           └─────────┘
        │                           │                     │
        └───────────────────────────┼─────────────────────┘
                                    │
                                    ↓
                        ┌──────────────────────────┐
                        │  MQTT 发送线程            │
                        │  (MQTT_DEVINFO 状态)     │
                        ├──────────────────────────┤
                        │ report_alarm_message()   │
                        │ report_interval_message()│
                        │ report_rt_message()      │
                        └──────────────────────────┘
                                    │
                                    ↓
                        mosquitto_publish() → 云平台
```
### 五、线程安全机制

所有链表操作都通过 pthread_mutex_t datalock 保护：
```
// 添加数据时加锁
publish_message_prepare() {
    pthread_mutex_lock(&report_msg->datalock);
    
    publish_type_interval(report_msg, data_pointer);  // 操作链表
    
    pthread_mutex_unlock(&report_msg->datalock);
}

// 发送数据时加锁
report_interval_message() {
    pthread_mutex_lock(&report_msg->datalock);
    
    list_for_each_entry_safe(...);  // 遍历链表发送
    
    pthread_mutex_unlock(&report_msg->datalock);
}
```
### 六、性能优化设计

1. 批量上报：payload_size 控制每次打包数量（默认50条），减少 MQTT 消息数量

2. 去重机制：report_data_rt 和 publish_type_interval() 只保留最新值

3. 分级处理：告警立即发送，普通数据批量发送

4. 内存管理：发送成功后立即释放节点，避免内存泄漏

---

### 七、总结对照表
| 链表名称               | 存储内容         | 数据类型           | 作用         | 处理函数                      |
| ------------------ | ------------ | -------------- | ---------- | ------------------------- |
| report_data_record | 变化上报的历史值     | data_format_st | 对比数据是否变化   | publish_type_change()     |
| report_data_rt     | 实时数据最新值      | data_format_st | 实时查询/快速上报  | publish_type_rt()         |
| report_data        | 待上报原始数据      | data_format_st | 累积数据等待打包   | publish_type_xxx()        |
| report_list        | 周期上报 JSON 消息 | JSON 字符串       | 等待发送到 MQTT | report_interval_message() |
| report_rt_list     | 实时上报 JSON 消息 | JSON 字符串       | 等待发送到 MQTT | report_rt_message()       |
| alarm_list         | 告警数据         | data_format_st | 优先发送告警     | report_alarm_message()    |
