# Base64 编解码实现详解

> 基于 `src/sdk/base64.c` 的实现讲解  
> 作者：C0
> 
---

## 目录

1. [Base64 基础原理](#base64-基础原理)
2. [核心数据结构](#核心数据结构)
3. [辅助函数](#辅助函数)
4. [编码实现](#编码实现)
5. [解码实现](#解码实现)
6. [边界处理详解](#边界处理详解)
7. [文件流式处理](#文件流式处理)
8. [总结与评估](#总结与评估)

---

## Base64 基础原理

### 编码规则

Base64 是一种将二进制数据编码为 ASCII 字符的方法：

- **输入**：任意二进制数据（字节流）
- **输出**：仅包含 64 个可打印字符的文本
- **转换比例**：每 3 字节 → 4 字符（膨胀率 33%）

### 字符集

```
索引 0-25  → A-Z
索引 26-51 → a-z
索引 52-61 → 0-9
索引 62    → +
索引 63    → /
填充符     → =
```

### 位操作原理

```
输入 3 字节（24位）：
  [AAAA AAAA] [BBBB BBBB] [CCCC CCCC]

拆分为 4 组（每组 6位）：
  [00AAAAAA] [00AABBBB] [00BBBBCC] [00CCCCCC]
     ↓          ↓          ↓          ↓
  查编码表   查编码表   查编码表   查编码表
```

---

## 核心数据结构

### 编码表

```c
unsigned char b64_chr[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
```

- 长度：64 个字符
- 索引与字符一一对应
- 编码时用于查表

---

## 辅助函数

### 1. `b64_int()` - ASCII 字符转索引

**功能**：将 Base64 字符反向映射为 0-64 的索引值

```c
unsigned int b64_int(unsigned int ch) {
    // ASCII to base64_int
    // 65-90  Upper Case  >>  0-25
    // 97-122 Lower Case  >>  26-51
    // 48-57  Numbers     >>  52-61
    // 43     Plus (+)    >>  62
    // 47     Slash (/)   >>  63
    // 61     Equal (=)   >>  64~
    if (ch==43)  return 62;         // '+'
    if (ch==47)  return 63;         // '/'
    if (ch==61)  return 64;         // '=' (填充符)
    if ((ch>47) && (ch<58))         // '0'-'9'
        return ch + 4;
    if ((ch>64) && (ch<91))         // 'A'-'Z'
        return ch - 'A';
    if ((ch>96) && (ch<123))        // 'a'-'z'
        return (ch - 'a') + 26;
    return 0;
}
```

**映射表**：

| 字符范围 | ASCII 码 | 返回值 | 说明 |
|---------|---------|-------|------|
| A-Z     | 65-90   | 0-25  | 大写字母 |
| a-z     | 97-122  | 26-51 | 小写字母 |
| 0-9     | 48-57   | 52-61 | 数字 |
| +       | 43      | 62    | 加号 |
| /       | 47      | 63    | 斜杠 |
| =       | 61      | **64** | **填充符（特殊值）** |

---

### 2. 尺寸计算函数

#### `b64e_size()` - 计算编码后尺寸

```c
unsigned int b64e_size(unsigned int in_size) {
    // size equals 4*floor((1/3)*(in_size+2));
    int i, j = 0;
    for (i=0; i<in_size; i++) {
        if (i % 3 == 0)
            j += 1;
    }
    return (4*j);
}
```

**公式**：`⌈输入字节数 / 3⌉ × 4`

**示例**：
- 输入 1 字节 → 输出 4 字符
- 输入 2 字节 → 输出 4 字符
- 输入 3 字节 → 输出 4 字符
- 输入 4 字节 → 输出 8 字符

---

#### `b64d_size()` - 估算解码后尺寸

```c
unsigned int b64d_size(unsigned int in_size) {
    return ((3*in_size)/4);
}
```

**注意**：这是估算值，未考虑填充符修正，实际可能少 1-2 字节。

---

## 编码实现

### `b64_encode()` - 内存版编码

```c
unsigned int b64_encode(const unsigned char* in, unsigned int in_len, unsigned char* out)
```

#### 主流程处理（每 3 字节一组）

```c
for (i=0; i<in_len; i++) {
    s[j++] = *(in+i);
    if (j==3) {
        // 位操作拆分
        out[k+0] = b64_chr[ (s[0]&255)>>2 ];
        out[k+1] = b64_chr[ ((s[0]&0x03)<<4)+((s[1]&0xF0)>>4) ];
        out[k+2] = b64_chr[ ((s[1]&0x0F)<<2)+((s[2]&0xC0)>>6) ];
        out[k+3] = b64_chr[ s[2]&0x3F ];
        j=0; k+=4;
    }
}
```

#### 位操作详解

假设输入 `s[0]=0x41, s[1]=0x42, s[2]=0x43` (字符 "ABC")

```
二进制表示：
  s[0] = 0100 0001
  s[1] = 0100 0010
  s[2] = 0100 0011

拆分为 6 位：
  out[0] = s[0]>>2               = 010000 (16) → 'Q'
  out[1] = (s[0]低2位 + s[1]高4位) = 010100 (20) → 'U'
  out[2] = (s[1]低4位 + s[2]高2位) = 001001 (9)  → 'J'
  out[3] = s[2]&0x3F             = 000011 (3)  → 'D'

结果：ABC → QUJD
```

**位运算分解**：

| 输出 | 位操作 | 取值范围 | 说明 |
|-----|--------|---------|------|
| `out[0]` | `(s[0]&255)>>2` | s[0] 的高 6 位 | 直接右移 2 位 |
| `out[1]` | `((s[0]&0x03)<<4) + ((s[1]&0xF0)>>4)` | s[0] 低 2 位 + s[1] 高 4 位 | 拼接操作 |
| `out[2]` | `((s[1]&0x0F)<<2) + ((s[2]&0xC0)>>6)` | s[1] 低 4 位 + s[2] 高 2 位 | 拼接操作 |
| `out[3]` | `s[2]&0x3F` | s[2] 的低 6 位 | 直接取低 6 位 |

---

## 解码实现

### `b64_decode()` - 内存版解码

```c
unsigned int b64_decode(const unsigned char* in, unsigned int in_len, unsigned char* out)
```

#### 主流程处理（每 4 字符一组）

```c
for (i=0; i<in_len; i++) {
    s[j++] = b64_int(*(in+i));  // 字符转索引
    if (j==4) {
        // 逆向重组
        out[k+0] = ((s[0]&255)<<2)+((s[1]&0x30)>>4);
        if (s[2]!=64) {
            out[k+1] = ((s[1]&0x0F)<<4)+((s[2]&0x3C)>>2);
            if ((s[3]!=64)) {
                out[k+2] = ((s[2]&0x03)<<6)+(s[3]); 
                k+=3;
            } else {
                k+=2;
            }
        } else {
            k+=1;
        }
        j=0;
    }
}
```

#### 位操作详解

假设输入 `"QUJD"` → 解码回 `"ABC"`

```
字符转索引：
  'Q' → 16 (010000)
  'U' → 20 (010100)
  'J' → 9  (001001)
  'D' → 3  (000011)

重组为 8 位：
  out[0] = (s[0]<<2) | (s[1]>>4)
         = (010000<<2) | (010100>>4)
         = 01000001 = 0x41 = 'A' ✓

  out[1] = (s[1]<<4) | (s[2]>>2)
         = (010100<<4) | (001001>>2)
         = 01000010 = 0x42 = 'B' ✓

  out[2] = (s[2]<<6) | s[3]
         = (001001<<6) | 000011
         = 01000011 = 0x43 = 'C' ✓
```

---

## 边界处理详解

### 编码边界处理（剩余字节不足 3）

#### 情况 1：剩余 **1 字节**

**示例**：输入 `0x41` (字符 'A')

```
原始数据：  [0100 0001]
补零后：    [0100 0001] [0000 0000] [填充] [填充]

拆分 6 位：
  out[0] = 0100 00  → 16 → 'Q'
  out[1] = 01 0000  → 4  → 'E'  (只有 s[0] 低 2 位有效)
  out[2] = '='      (无效数据填充)
  out[3] = '='      (无效数据填充)

编码结果：QE==
```

**代码执行**：

```c
if (j==1)
    s[1] = 0;  // 手动补零
out[k+0] = b64_chr[ (s[0]&255)>>2 ];                    // 'Q'
out[k+1] = b64_chr[ ((s[0]&0x03)<<4)+((s[1]&0xF0)>>4) ]; // 'E'
out[k+2] = '=';  // j!=2 走 else 分支
out[k+3] = '=';
```

---

#### 情况 2：剩余 **2 字节**

**示例**：输入 `0x41 0x42` (字符 'AB')

```
原始数据：  [0100 0001] [0100 0010]
补零后：    [0100 0001] [0100 0010] [0000 0000填充]

拆分 6 位：
  out[0] = 0100 00    → 16 → 'Q'
  out[1] = 01 0100    → 20 → 'U'
  out[2] = 0010 00    → 8  → 'I'  (只有 s[1] 低 4 位有效)
  out[3] = '='        (无效数据填充)

编码结果：QUI=
```

**代码执行**：

```c
s[0] = 0x41;
s[1] = 0x42;
out[k+0] = b64_chr[(0x41 >> 2)];                              // 'Q'
out[k+1] = b64_chr[((0x41&0x03)<<4) + ((0x42&0xF0)>>4)];      // 'U'
out[k+2] = b64_chr[((0x42&0x0F)<<2)];                         // 'I' (j==2 走 if 分支)
out[k+3] = '=';
```

---

### 解码边界处理（遇到填充符 `=`）

**关键**：`b64_int('=')` 返回 **64**，作为填充标记。

---

#### 情况 1：**s[2]==64** → 输出 1 字节

**示例**：解码 `"QE=="`

```
输入字符：  Q       E       =       =
转换索引：  16      4       64      64
           s[0]    s[1]    s[2]    s[3]

重组过程：
  out[0] = (s[0]<<2) | (s[1]>>4)
         = (010000<<2) | (000100>>4)
         = 01000000 | 00000000
         = 01000001 = 0x41 = 'A' ✓

  检测到 s[2]==64 → 停止，只输出 1 字节
```

**代码路径**：

```c
out[k+0] = ((s[0]<<2) + (s[1]>>4));  // 0x41
if (s[2]!=64) {
    // 不执行
} else {
    k+=1;  // ← 只输出 1 字节
}
```

---

#### 情况 2：**s[3]==64** → 输出 2 字节

**示例**：解码 `"QUI="`

```
输入字符：  Q       U       I       =
转换索引：  16      20      8       64
           s[0]    s[1]    s[2]    s[3]

重组过程：
  out[0] = (s[0]<<2) | (s[1]>>4)
         = 01000001 = 0x41 = 'A' ✓

  out[1] = (s[1]<<4) | (s[2]>>2)
         = (010100<<4) | (001000>>2)
         = 01000010 = 0x42 = 'B' ✓

  检测到 s[3]==64 → 停止，输出 2 字节
```

**代码路径**：

```c
out[k+0] = ((s[0]<<2) + (s[1]>>4));           // 0x41
if (s[2]!=64) {
    out[k+1] = ((s[1]<<4) + (s[2]>>2));       // 0x42
    if ((s[3]!=64)) {
        // 不执行
    } else {
        k+=2;  // ← 输出 2 字节
    }
}
```

---

#### 情况 3：**无填充符** → 输出 3 字节

正常的 4 字符组，全部有效数据。

```c
out[k+0] = ...;
out[k+1] = ...;
out[k+2] = ...;
k+=3;  // 输出完整 3 字节
```

---

### 边界处理总结表

| 填充情况 | 输入字节 | 有效位数 | 编码输出 | 解码检测 | 解码输出 |
|---------|---------|---------|---------|---------|---------|
| 无填充   | 3 字节  | 24 位   | 4 字符  | s[2]!=64 && s[3]!=64 | 3 字节 |
| 1 个 `=` | 2 字节  | 16 位   | 3 字符+`=` | s[3]==64 | 2 字节 |
| 2 个 `=` | 1 字节  | 8 位    | 2 字符+`==` | s[2]==64 | 1 字节 |

---

## 文件流式处理

### `b64_encodef()` - 文件编码

```c
unsigned int b64_encodef(char *InFile, char *OutFile)
```

**特点**：
- 逐字节读取，不需预先分配大缓冲区
- 适合处理大文件（内存占用低）
- 使用 `fgetc()` 和 `fputc()` 流式操作

**核心逻辑**：

```c
while(c!=EOF) {
    c=fgetc(pInFile);
    if (c==EOF) break;
    s[j++]=c;
    if (j==3) {
        // 与内存版相同的编码逻辑
        fputc(b64_chr[...], pOutFile);
        ...
    }
}
// 边界处理同内存版
```

---

### `b64_decodef()` - 文件解码

```c
unsigned int b64_decodef(char *InFile, char *OutFile)
```

**实现方式**：与编码文件版类似，逐字符读取并解码。

---

## 总结与评估

### 优点

1. **实现简洁**：代码清晰，位操作直观
2. **双接口设计**：
   - 内存版：`b64_encode()` / `b64_decode()`
   - 文件版：`b64_encodef()` / `b64_decodef()`
3. **符合标准**：遵循 RFC 4648 Base64 规范
4. **无外部依赖**：仅使用标准库

---

### 潜在问题

| 问题 | 影响 | 建议修复 |
|-----|------|---------|
| **无输入验证** | 非法 Base64 字符会导致错误结果 | 在 `b64_decode()` 中添加字符合法性检查 |
| **尺寸估算不精确** | `b64d_size()` 未考虑填充符，可能多分配 1-2 字节 | 改为 `(in_size*3/4) + 3` 预留安全空间 |
| **错误处理不足** | 文件操作失败统一返回 0，无法区分错误类型 | 返回负数错误码或使用枚举类型 |
| **缓冲区溢出风险** | 调用者必须预先分配足够内存，否则会溢出 | 添加输出缓冲区大小参数进行边界检查 |

---

### 使用建议

#### 编码示例

```c
unsigned char input[] = "Hello, World!";
unsigned char output[100];
unsigned int len = b64_encode(input, strlen(input), output);
printf("编码结果: %s (长度: %u)\n", output, len);
// 输出: SGVsbG8sIFdvcmxkIQ==
```

#### 解码示例

```c
unsigned char input[] = "SGVsbG8sIFdvcmxkIQ==";
unsigned char output[100];
unsigned int len = b64_decode(input, strlen(input), output);
output[len] = '\0';  // 添加字符串终止符
printf("解码结果: %s (长度: %u)\n", output, len);
// 输出: Hello, World!
```

---

### 学习要点

1. **掌握位运算**：理解移位和掩码操作的组合使用
2. **边界条件处理**：理解填充符的作用和检测机制
3. **内存管理**：调用者需负责分配足够的输出缓冲区
4. **流式处理思想**：文件版展示了如何处理大数据而不占用过多内存

---

## 附录：快速参考

### API 清单

| 函数 | 功能 | 返回值 |
|-----|------|-------|
| `b64_int(ch)` | 字符转索引 | 0-64 |
| `b64e_size(in_size)` | 计算编码后尺寸 | 字节数 |
| `b64d_size(in_size)` | 估算解码后尺寸 | 字节数 |
| `b64_encode(in, in_len, out)` | 内存编码 | 输出长度 |
| `b64_decode(in, in_len, out)` | 内存解码 | 输出长度 |
| `b64_encodef(InFile, OutFile)` | 文件编码 | 输出长度 |
| `b64_decodef(InFile, OutFile)` | 文件解码 | 输出长度 |

---

### 位掩码速查

```c
0x03 = 0000 0011  // 取低 2 位
0x0F = 0000 1111  // 取低 4 位
0x30 = 0011 0000  // 取第 4-5 位
0x3C = 0011 1100  // 取第 2-5 位
0x3F = 0011 1111  // 取低 6 位
0xC0 = 1100 0000  // 取高 2 位
0xF0 = 1111 0000  // 取高 4 位
0xFF = 1111 1111  // 全 8 位
```

---

**文档版本**：v1.0  
**更新日期**：2025-11-01  
**适用代码**：`src/sdk/base64.c` (205 行)

