## 📆 每日总结

**日期：** 2025-10-22  
**项目：** 联通OSDT数据上报适配  

### ✅ 今日完成
- 修复 CUIOT 插件初始化阶段段错误问题
- 优化uci_info数据上报格式与性能
- 适配 UCI 配置信息上报
- 进行完整的端到端联调测试
- 验证属性上报功能完整性

### 🧩 问题与解决
### 问题：程序运行到服务初始化时发生段错误
**现象：**
```
[DEBUG] cuiot_service_init: Before calling service[0].init_func()
[DEBUG] init_func_reboot: set_param_id success
Segmentation fault
```

**原因：**
- `g_service_function` 数组被声明为 `const`（只读内存段）
- 初始化函数尝试修改数组元素的 `param_list` 字段：`sft->param_list = spt;`
- 对只读内存写入触发段错误保护机制

**解决：**
- 修改 `cuiot_sevice.c` 第69行：去掉 `const` 关键字
  ```c
  // 修改前
  const service_function_t g_service_function[T_MAX_F] = { ... };
  
  // 修改后
  service_function_t g_service_function[T_MAX_F] = { ... };
  ```
- 验证通过：程序可正常完成所有19个服务的初始化

### 💡 今日收获
  ### 1. `popen()` vs `fopen()` 的本质区别

	**关键认识**：`popen()` 并非简单的文件打开，而是通过创建子进程并执行 Shell 命令实现数据管道通信，这在嵌入式系统中代价高昂。

	- **系统调用路径差异**：  
	  `popen()` → `fork()` → `exec("/bin/sh -c ...")` → `pipe()` → 父进程读取输出  
	  `fopen()` → 直接调用 `open()` → 文件描述符 → 用户态缓冲区  
	  👉 `popen()` 每次都会触发进程创建与上下文切换，而 `fopen()` 仅涉及内核文件 I/O。
	
	- **性能与资源开销**：  
	  `popen()` 创建额外进程与管道，占用更多内存与文件描述符，频繁调用会导致系统负载上升。  
	  `fopen()` 仅依赖文件系统缓存，I/O 稳定且可控。
	
	- **最佳实践**：  
	  对于固定配置（如 `/etc/config/system`）或静态信息读取，应使用 `fopen()`。  
	  仅在需要动态执行命令（如 `ps`, `ifconfig`）时才考虑 `popen()`，且应限制调用频率。

	
### 🗓️ 明日计划
- （明天要推进的任务或验证目标）
- （例如：进行VPN状态上报的联调测试）
- [x] 增加系统判断，根据不同的系统选择不同的上报模式
- [x] 内存泄漏检测：使用valgrind进行长时间运行测试